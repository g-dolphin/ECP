countryconc$c_gloria[countryconc$c_ecp=="Kiribati"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="Korea, Dem. Rep."]<-"North Korea"
countryconc$c_gloria[countryconc$c_ecp=="Korea, Rep."]<-"South Korea"
countryconc$c_gloria[countryconc$c_ecp=="Kosovo"]<-"Rest of Europe"
countryconc$c_gloria[countryconc$c_ecp=="Lao PDR"]<-"Laos"
countryconc$c_gloria[countryconc$c_ecp=="Lesotho"]<-"Rest of Africa"
countryconc$c_gloria[countryconc$c_ecp=="Liechtenstein"]<-"Rest of Europe"
countryconc$c_gloria[countryconc$c_ecp=="Macao SAR, China"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="Maldives"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="Marshall Islands"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="Mauritius"]<-"Rest of Africa"
countryconc$c_gloria[countryconc$c_ecp=="Monaco"]<-"Rest of Europe"
countryconc$c_gloria[countryconc$c_ecp=="Montenegro"]<-"Rest of Europe"
countryconc$c_gloria[countryconc$c_ecp=="Nauru"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="Nigeria"]<-"Nigeria"
countryconc$c_gloria[countryconc$c_ecp=="North Macedonia"]<-"Macedonia"
countryconc$c_gloria[countryconc$c_ecp=="Palau"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="Puerto Rico"]<-"Rest of Americas"
countryconc$c_gloria[countryconc$c_ecp=="Russian Federation"]<-"USSR/Russian Federation (1990/1991)"
countryconc$c_gloria[countryconc$c_ecp=="Samoa"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="San Marino"]<-"Rest of Europe"
countryconc$c_gloria[countryconc$c_ecp=="Sao Tome and Principe"]<-"Rest of Africa"
countryconc$c_gloria[countryconc$c_ecp=="Serbia"]<-"Yugoslavia/Serbia (1991/1992)"
countryconc$c_gloria[countryconc$c_ecp=="Seychelles"]<-"Rest of Africa"
countryconc$c_gloria[countryconc$c_ecp=="Solomon Islands"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="South Africa"]<-"South Africa"
countryconc$c_gloria[countryconc$c_ecp=="South Sudan"]<-"South Sudan"
countryconc$c_gloria[countryconc$c_ecp=="St. Kitts and Nevis"]<-"Rest of Americas"
countryconc$c_gloria[countryconc$c_ecp=="St. Lucia"]<-"Rest of Americas"
countryconc$c_gloria[countryconc$c_ecp=="St. Vincent and the Grenadines"]<-"Rest of Americas"
countryconc$c_gloria[countryconc$c_ecp=="Suriname"]<-"Rest of Americas"
countryconc$c_gloria[countryconc$c_ecp=="Swaziland"]<-"Rest of Africa"
countryconc$c_gloria[countryconc$c_ecp=="Taiwan, China"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="Timor-Leste"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="Tonga"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="Trinidad and Tobago"]<-"Rest of Americas"
countryconc$c_gloria[countryconc$c_ecp=="Tuvalu"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="United Kingdom"]<-"United Kingdom"
countryconc$c_gloria[countryconc$c_ecp=="United States"]<-"United States of America"
countryconc$c_gloria[countryconc$c_ecp=="Vanuatu"]<-"Rest of Asia-Pacific"
countryconc$c_gloria[countryconc$c_ecp=="Vatican City"]<-"Rest of Europe"
countryconc$c_gloria[countryconc$c_ecp=="Vietnam"]<-"Viet Nam"
countryconc$c_gloria[countryconc$c_ecp=="West Bank and Gaza"]<-"Palestine"
countryconc$c_gloria[countryconc$c_ecp=="Western Sahara"]<-"Rest of Africa"
View(countryconc)
View(countryconc)
View(region_ind)
countryconc<-rbind(countryconc,c("Yemen, Rep.","DR Yemen (Aden)"))
View(countryconc)
rm(region_ind)
k=20
### Print progress
print(paste("working on year",yrs[k]))
### Step 1: Import data
load(file.path(fpg,paste0("gloria_",yrs[k],".RData")))
### Step 2: Run for sectoral satellites
# add row into data (i.e., rows corresponding to author-created indicators are added to the Satellite account matrix)
nr<-nrow(tqm)+1
zq<-rbind(tqm,NA)
fcq<-sequential_ind$fcq
fsq<-sequential_ind$fsq
# fill in for each column
for(r in 1:ncol(zq)){
print(r)
tmpc<-fcq[r] # the country
tmps<-fsq[r] # the sector
# If we have ecp data for the country, we fill in
zq[nr,r]<-calculate_ewcp(yr = yrs[k],
ecp_jur = countryconc$c_ecp[countryconc$c_gloria==tmpc],
ctry = tmpc,
sect = tmps,
ecp_data = ecp,
gloria_q_data = zq,
concordance = conclist[[tmps]],
type = "z")
}
View(zq)
### Setup
wd<-file.path(here::here(),"_code","compilation","ecp","industry")
setwd(wd)
### Datamatch
ecpmwd<-file.path(wd,"2_match")
sattype<-"EDGAR"
source(file.path(ecpmwd,"match_gloria_ecp.R"))
k20
k=20
### Print progress
print(paste("working on year",yrs[k]))
### Step 1: Import data
load(file.path(fpg,paste0("gloria_",yrs[k],".RData")))
### Step 2: Run for sectoral satellites
# add row into data (i.e., rows corresponding to author-created indicators are added to the Satellite account matrix)
nr<-nrow(tqm)+1
zq<-rbind(tqm,NA)
fcq<-sequential_ind$fcq
fsq<-sequential_ind$fsq
# add row into data
nr<-nrow(yqm)+1
yq<-rbind(yqm,NA)
fcq<-sequentiald_ind$fcqd
fsq<-sequentiald_ind$demandind
r=1
tmpc<-fcq[r] # the country
tmps<-fsq[r] # the sector
dim(yq)
View(conclist)
for(r in 1:ncol(yq)){
tmpc<-fcq[r] # the country
tmps<-fsq[r] # the sector
# fill in
yq[nr,r]<-calculate_ewcp(yr = yrs[k],
ecp_jur = countryconc$c_ecp[countryconc$c_gloria==tmpc],
sattype = sattype,
ctry = tmpc,
sect = tmps,
ecp_data = ecp,
gloria_q_data = yq,
concordance = conclist[['Other Services']], # we choose a non-modified concordance here
type = "y")
}
for(r in 1:ncol(yq)){
tmpc<-fcq[r] # the country
tmps<-fsq[r] # the sector
# fill in
yq[nr,r]<-calculate_ewcp(yr = yrs[k],
ecp_jur = countryconc$c_ecp[countryconc$c_gloria==tmpc],
sattype = sattype,
ctry = tmpc,
sect = tmps,
ecp_data = ecp,
gloria_q_data = yq,
concordance = conclist[['Other Services']], # we choose a non-modified concordance here
type = "y")
}
r=1
tmpc<-fcq[r] # the country
tmps<-fsq[r] # the sector
yr = yrs[k]
ecp_jur = countryconc$c_ecp[countryconc$c_gloria==tmpc]
sattype = sattype
ctry = tmpc
sect = tmps
ecp_data = ecp
gloria_q_data = yq
concordance = conclist[['Other Services']] # we choose a non-modified concordance here
type = "y"
### Step 1: Create calculation dataframe
df<-as.data.frame(matrix(NA,nrow=nrow(concordance),ncol=2))
concordance = conclist[['Other Services']] # we choose a non-modified concordance here
View(conclist)
concordance = conclist[['Other services']] # we choose a non-modified concordance here
type = "y"
### Step 1: Create calculation dataframe
df<-as.data.frame(matrix(NA,nrow=nrow(concordance),ncol=2))
for(r in 1:ncol(yq)){
tmpc<-fcq[r] # the country
tmps<-fsq[r] # the sector
# fill in
yq[nr,r]<-calculate_ewcp(yr = yrs[k],
ecp_jur = countryconc$c_ecp[countryconc$c_gloria==tmpc],
sattype = sattype,
ctry = tmpc,
sect = tmps,
ecp_data = ecp,
gloria_q_data = yq,
concordance = conclist[['Other services']], # we choose a non-modified concordance here
type = "y")
}
warnings()
yr = yrs[k]
ecp_jur = countryconc$c_ecp[countryconc$c_gloria==tmpc]
sattype = sattype
ctry = tmpc
sect = tmps
ecp_data = ecp
gloria_q_data = yq
concordance = conclist[['Other services']] # we choose a non-modified concordance here
type = "y"
### Step 1: Create calculation dataframe
df<-as.data.frame(matrix(NA,nrow=nrow(concordance),ncol=2))
colnames(df)<-c("Sat_ind","cp")
df$Sat_ind<-concordance$Sat_ind
# the below is to make the function work for both industry satellites z
# and demand satellites y
if(type=="z"){
sectorf<-sequential_ind$Sequential_regionSector_labels[sequential_ind$fcq==ctry & sequential_ind$fsq==sect]
} else if(type=="y"){
sectorf=sequentiald_ind$Sequentiald_finalDemand_labels[sequentiald_ind$fcqd==ctry & sequentiald_ind$demandind==sect]
}
### Step 2: Extract ecp data
# Two cases
if(length(ecp_jur)==1){ # if there is only country
de<-ecp_data %>% filter(jurisdiction == ecp_jur, year==yr)
de$jurisdiction <- ctry
} else { # if there are several then we need to aggregate
de<- ecp_data %>%
filter (jurisdiction %in% ecp_jur,year==yr) %>%
mutate (ecp_co2 = `CO2`*`ecp_all_usd`) %>%
group_by(ipcc_code) %>%
summarise(`CO2`=sum(`CO2`),`ecp_co2`=sum(ecp_co2)) %>%
mutate(ecp_all_usd = ecp_co2/`CO2`)
de$ecp_all_usd[is.na(de$ecp_all_usd)]<-0
de['jurisdiction']<-ctry
}
View(sequentiald_ind)
sequentiald_ind$Sequentiald_finalDemand_labels[sequentiald_ind$fcqd==ctry & sequentiald_ind$demandind==sect]
sequentiald_ind$Sequential_finalDemand_labels[sequentiald_ind$fcqd==ctry & sequentiald_ind$demandind==sect]
calculate_ewcp<-function(yr,
ecp_jur,
sattype,
ctry,
sect,
ecp_data,
gloria_q_data,
concordance,
type,
sourcedat)
{
# This function is written for easy debugging
### Step 1: Create calculation dataframe
df<-as.data.frame(matrix(NA,nrow=nrow(concordance),ncol=2))
colnames(df)<-c("Sat_ind","cp")
df$Sat_ind<-concordance$Sat_ind
# the below is to make the function work for both industry satellites z
# and demand satellites y
if(type=="z"){
sectorf<-sequential_ind$Sequential_regionSector_labels[sequential_ind$fcq==ctry & sequential_ind$fsq==sect]
} else if(type=="y"){
sectorf=sequentiald_ind$Sequential_finalDemand_labels[sequentiald_ind$fcqd==ctry & sequentiald_ind$demandind==sect]
}
### Step 2: Extract ecp data
# Two cases
if(length(ecp_jur)==1){ # if there is only country
de<-ecp_data %>% filter(jurisdiction == ecp_jur, year==yr)
de$jurisdiction <- ctry
} else { # if there are several then we need to aggregate
de<- ecp_data %>%
filter (jurisdiction %in% ecp_jur,year==yr) %>%
mutate (ecp_co2 = `CO2`*`ecp_all_usd`) %>%
group_by(ipcc_code) %>%
summarise(`CO2`=sum(`CO2`),`ecp_co2`=sum(ecp_co2)) %>%
mutate(ecp_all_usd = ecp_co2/`CO2`)
de$ecp_all_usd[is.na(de$ecp_all_usd)]<-0
de['jurisdiction']<-ctry
}
### Step 3: Extract gloria satellites data
# sattype rows, countrysector column
if(type=="z"){
zqs<-zq[which(grepl(sattype,satellites_ind$Sat_head_indicator)),r]
} else if(type=="y"){
# rename colnames
zqs<-yq[which(grepl(sattype,satellites_ind$Sat_head_indicator)),r]
}
# add to df
df['emissions']<-zqs
### Step 4: Import concordance between ipcc sectors in ECP and in GLORIA
i_c_p <- concordance %>% pivot_longer(-Sat_ind,names_to="cp_ind",values_to="ident")
### Step 5: Map carbon price data from ECP to GLORIA EDGAR categories
# this is an aggregation from 76 categories to 73 categories
for(i in 2:nrow(df)){
# extract names of the ECP categories that correspond to GLORIA EDGAR categories
tmpnms1<-vector()
tmpnms2<-vector()
tmpnms3<-vector()
tmpnms1<-i_c_p$cp_ind[i_c_p$ident==1 & i_c_p$Sat_ind==df$Sat_ind[i]]
tmpnms2<-i_c_p$cp_ind[i_c_p$ident==2 & i_c_p$Sat_ind==df$Sat_ind[i]]
tmpnms3<-i_c_p$cp_ind[i_c_p$ident==3 & i_c_p$Sat_ind==df$Sat_ind[i]]
if(length(tmpnms1==1)){ # if there is unique concordance then use that
df$cp[i]<-de$ecp_all_usd[de$ipcc_code==tmpnms1]
} else if (length(tmpnms2==1)){ # if we only have a lower resolution ecp, use that (e.g. 1A1C price for 1A1ci emissions)
df$cp[i]<-de$ecp_all_usd[de$ipcc_code==tmpnms2]
} else if (length(tmpnms3)>0){ # if we only have a higher resolution ecp, then use the emissions-weighted average
tmpvectp<-vector()
# extract the carbon price data for the subcategories
tmpvectc<-vector()
for(j in 1:length(tmpnms3)){
tmpvectp[j]<-de$ecp_all_usd[de$ipcc_code==tmpnms3[j]]
tmpvectc[j]<-de$CO2[de$ipcc_code==tmpnms3[j]]
}
if(sum(tmpvectc)>0){ # if there are any emissions
df$cp[i]<-sum((tmpvectc*tmpvectp)/sum(tmpvectc)) # compute emissions-weighted average
} else {
df$cp[i]<-0 # in case there are no emissions, we assume zero (otherwise division by zero generates NA)
}
} else {} # otherwise e.g. in case of 5B, where we have no conc, do nothing
}
### Step 6: Rename 5 digit codes
df$Sat_ind[df$Sat_ind=="1A1ci"]<-"1A1c1"
df$Sat_ind[df$Sat_ind=="1A1cii"]<-"1A1c2"
df$Sat_ind[df$Sat_ind=="1A4ci"]<-"1A4c1"
df$Sat_ind[df$Sat_ind=="1A4cii"]<-"1A4c2"
df$Sat_ind[df$Sat_ind=="1A4ciii"]<-"1A4c3"
### Step 7: Calculate emissions-weighted average carbon price for missing cases
# we identify the applicable carbon price for each category with emissions
# this step is only there for special cases (1A2, 1A3b, 3C1). If these categories
# have no price, but subcategories do, then we calculate the emissions-weighted
# average across subcategories and use the result.
df['acp']<-NA
for(i in 1:nrow(df)){
# find all subcategories
tmpnms<-vector()
tmpnms<-df[startsWith(df$Sat_ind, df$Sat_ind[i]),1]
tmpnms<-tmpnms[-1] # keep only subcategories
# get prices for those subcategories
tmpvectp<-df$cp[df$Sat_ind %in% tmpnms]
# get carbon for those subcategories
tmpvectc<-df$emissions[df$Sat_ind %in% tmpnms]
# if the main category has no aggregate price, but subcategories do,
# we use the emissions-weighted average price across subcategories
if (df$cp[i] == 0 & sum(tmpvectp) > 0) {
df$acp[i] <- sum(tmpvectp*tmpvectc)/sum(tmpvectc)
} else { # otherwise we use the price of the main category (it might be 0)
df$acp[i] <- df$cp[i]
}
}
### Step 8: Calculate overall emissions-weighted carbon price for the sector
# divide categorical emissions by total
df['relem']<-df$emissions/df$emissions[df$Sat_ind=="total"]
# if we have zero total emissions this introduces NAs. Change those cases to zero
# df$relem[is.na(df$relem)]<-0
# multiply relative emissions by categorical prices
df['relcc']<-df$relem*df$acp
df$relcc[df$Sat_ind=="total"]<-0
# result is the sum of all categorical weighted prices
result<-sum(df$relcc)
### Step 9: Return result
return(result)
}
for(r in 1:ncol(yq)){
tmpc<-fcq[r] # the country
tmps<-fsq[r] # the sector
# fill in
yq[nr,r]<-calculate_ewcp(yr = yrs[k],
ecp_jur = countryconc$c_ecp[countryconc$c_gloria==tmpc],
sattype = sattype,
ctry = tmpc,
sect = tmps,
ecp_data = ecp,
gloria_q_data = yq,
concordance = conclist[['Other services']], # we choose a non-modified concordance here
type = "y")
}
View(yq)
### Setup
wd<-file.path(here::here(),"_code","compilation","ecp","industry")
setwd(wd)
### Datamatch
ecpmwd<-file.path(wd,"2_match")
sattype<-"EDGAR"
source(file.path(ecpmwd,"match_gloria_ecp.R"))
### Setup
wd<-file.path(here::here(),"_code","compilation","ecp","industry")
setwd(wd)
### Import data
gloriawd<-file.path(wd,"1_import","gloria")
source(file.path(gloriawd,"run_imports.R"))
### Setup
wd<-file.path(here::here(),"_code","compilation","ecp","industry")
setwd(wd)
### Import data
gloriawd<-file.path(wd,"1_import","gloria")
dir.create(file.path(gloriawd, "tmpdir"))
timestep<-"1990"
qcode<-"20230310"
mcode<-"20230314"
################################################################################
### Script to get GLORIA IO data
################################################################################
### 1 Directories & packages ###################################################
library(dplyr)
library(data.table)
library(Rfast)
library(readxl)
### specify here the filepath where the data is located
fpe<-file.path("C:", "Users", "jomerkle",
"OneDrive - Norwegian University of Life Sciences",
"data",
"GLORIA",
"057",
timestep)
## notes:
# economic values in k USD basic price
# we have 120 sectors. Industries, products, industries, products.
# We delete the product part, as we do not need it.
# we have 164 countries, and 120 sectors
# we only need markup001 (basic prices)
### 1 Import Satellite data ####################################################
# this just to create a vector of index numbers for those rows and columns we want to keep
# we want to keep only MRIO data, so remove the supply matrices within
# fread is a faster reader than read.csv
39360/(2*120)
sec<-seq(1:39360) # sequence of numbers (for columns)
ser<-seq(1:39360) # sequence of numbers (for rows)
ones<-rep(1,times=120)
zeros<-rep(0,times=120)
oz<-c(ones,zeros)
full<-rep(oz,times=164)
sec[full==0]<-NA
ser[full==1]<-NA
cselector<-sec[!is.na(sec)] # removes NA values (from columns sequence)
rselector<-ser[!is.na(ser)] # removes NA values (from rows sequence)
rm(full,ones,oz,ser,sec,zeros) # remove objects no longer needed
# satellites for transaction data (reads the satellite data with fread)
tq<-data.table::fread(file = file.path(fpe,
paste0(qcode,
"_120secMother_AllCountries_002_TQ-Results_",
timestep,
"_057_Markup001(full).csv")
),
header = F,
select = cselector)
tqm<-as.matrix(tq)
yq<-read.csv(file.path(fpe,
paste0(qcode,
"_120secMother_AllCountries_002_YQ-Results_",
timestep,
"_057_Markup001(full).csv")
),
header = F)
yqm<-as.matrix(yq)
rm(tq,yq)
# import index data
sector_ind <- read_excel(file.path(fpe,"..","GLORIA_ReadMe_057.xlsx"),sheet = "Sectors")
region_ind <- read_excel(file.path(fpe,"..","GLORIA_ReadMe_057.xlsx"),sheet = "Regions")
satellites_ind <- read_excel(file.path(fpe,"..","GLORIA_ReadMe_057.xlsx"),sheet = "Satellites")
demand_ind <- read_excel(file.path(fpe,"..","GLORIA_ReadMe_057.xlsx"),sheet = "Value added and final demand")
sequential_ind <- read_excel(file.path(fpe,"..","GLORIA_ReadMe_057.xlsx"),sheet = "Sequential region-sector labels")
# shorten sequential_ind to reflect the non-product version
all_c_s<-sequential_ind$Sequential_regionSector_labels
short_c_s<-all_c_s[cselector]
sequential_ind$Sequential_regionSector_labels<-NA
sequential_ind<-sequential_ind[1:length(short_c_s),]
sequential_ind$Sequential_regionSector_labels<-short_c_s
# create full countrylabel and full sectorlabel vectors
cq<-region_ind$Region_names
fcql<-list()
for(i in 1:length(cq)){
fcql[[i]]<-rep(cq[i],times=nrow(sector_ind))
}
sequential_ind['fcq']<-do.call("c",fcql)
sequential_ind['fsq']<-rep(sector_ind$Sector_names,times=nrow(region_ind))
sequentiald_ind<- sequential_ind %>% select(Sequential_finalDemand_labels) %>% drop_na()
library(tidyr)
sequentiald_ind<- sequential_ind %>% select(Sequential_finalDemand_labels) %>% drop_na()
### Setup
wd<-file.path(here::here(),"_code","compilation","ecp","industry")
setwd(wd)
### Import data
gloriawd<-file.path(wd,"1_import","gloria")
source(file.path(gloriawd,"run_imports.R"))
pl<-"curr_p"
ecpwd<-file.path(wd,"1_import","ecp")
source(file.path(ecpwd,"import_ecp.R"))
### Datamatch
ecpmwd<-file.path(wd,"2_match")
sattype<-"EDGAR"
source(file.path(ecpmwd,"match_gloria_ecp.R"))
### Reformat and Save
yrs<-seq(1990,2022)
zql<-list()
yql<-list()
for(i in 1:length(yrs)){
## 1. Fetch data
load(file.path(ecpmwd,"tmpdir",yrs[i],"ecp_gloria.RData"))
## 2. Get industry level data
zqdf<-as.data.frame(matrix(nrow=nrow(sequential_ind),ncol=6))
colnames(zqdf)<-c("year","country_sector","country","sector","ecp","CO2")
zqdf$year<-yrs[i]
zqdf$country_sector<-sequential_ind$Sequential_regionSector_labels
zqdf$country<-sequential_ind$fcq
zqdf$sector<-sequential_ind$fsq
# ecp is always in the bottom row
zqdf$ecp<-zq[nrow(zq),]
# total emissions row is given by satellites_ind
zqdf$CO2<-zq[which(grepl(sattype,satellites_ind$Sat_head_indicator) & grepl("total",satellites_ind$Sat_indicator)),]
# move into list element
zql[[i]]<-zqdf
rm(zqdf)
## 3. Get industry level data
yqdf<-as.data.frame(matrix(nrow=nrow(sequentiald_ind),ncol=6))
colnames(yqdf)<-c("year","country_sector","country","sector","ecp","CO2")
yqdf$year<-yrs[i]
yqdf$country_sector<-sequentiald_ind$Sequential_finalDemand_labels
yqdf$country<-sequentiald_ind$fcqd
yqdf$sector<-sequentiald_ind$demandind
# ecp is always in the bottom row
yqdf$ecp<-yq[nrow(yq),]
# total emissions row is given by satellites_ind
yqdf$CO2<-yq[which(grepl(sattype,satellites_ind$Sat_head_indicator) & grepl("total",satellites_ind$Sat_indicator)),]
# move into list element
yql[[i]]<-yqdf
rm(yqdf)
}
zqd<-do.call("rbind",zql)
yqd<-do.call("rbind",yql)
View(zqd)
View(yqd)
if(pl=="curr_p"){
write.csv(zqd,file.path(here::here(),
"_dataset","ecp","industry","ecp_gloria_sectors",
"edgar_based","currentPrice","FlexXRate",
"ecp_gloria_industry_CO2.csv"))
write.csv(yqd,file.path(here::here(),
"_dataset","ecp","industry","ecp_gloria_sectors",
"edgar_based","currentPrice","FlexXRate",
"ecp_gloria_finaldem_CO2.csv"))
}
### clean up
unlink(file.path(wd,"1_import","ecp","tmpdir"),recursive = T)
unlink(file.path(wd,"1_import","gloria","tmpdir"),recursive = T)
unlink(file.path(wd,"2_match","tmpdir"),recursive = T)
rm(list=ls())
